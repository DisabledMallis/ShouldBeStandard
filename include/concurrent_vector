#pragma once

#ifndef SBS_CONCURRENT_VECTOR
#define SBS_CONCURRENT_VECTOR

#include "internal/sbs_macros.h"

#include <atomic>
#include <iterator>
#include <mutex>
#include <optional>
#include <vector>

_BEGIN_SBS
template<typename T, typename Allocator = std::allocator<T>>
class concurrent_vector
{
public:
	using value_type = T;
	using reference = T&;
	using const_reference = const T&;
	using pointer = T*;
	using const_pointer = const T*;
	using difference_type = ptrdiff_t;
	using size_type = size_t;
	using allocator_type = Allocator;

	using iterator = std::vector<T>::iterator;
	using const_iterator = std::vector<T>::const_iterator;
	using reverse_iterator = std::vector<T>::reverse_iterator;
	using reverse_const_iterator = std::vector<T>::reverse_const_iterator;

	constexpr explicit concurrent_vector(const Allocator& alloc) noexcept {}
	constexpr concurrent_vector(size_type count, const T& value, const Allocator& alloc = Allocator())
	{
		this->mData.resize(count);
	}
	template<class InputIt>
	constexpr concurrent_vector(InputIt first, InputIt last, const Allocator& alloc = Allocator()) {}
	constexpr concurrent_vector(const concurrent_vector& other) {}
	constexpr concurrent_vector(const concurrent_vector& other, const Allocator& alloc) {}
	constexpr concurrent_vector(concurrent_vector&& other) noexcept {}
	constexpr concurrent_vector(concurrent_vector&& other, const Allocator& alloc) {}
	constexpr concurrent_vector(std::initializer_list<T> init, const Allocator& alloc) {}
	template<typename R>
	constexpr concurrent_vector(std::from_range_t, R&& rg, const Allocator& alloc = Allocator()) {}

	constexpr ~concurrent_vector() = default;

	constexpr concurrent_vector& operator=(const concurrent_vector& other)
	{
		return *this;
	}
	concurrent_vector& operator=(concurrent_vector&& other) noexcept
	{
		return *this;
	}
	constexpr concurrent_vector& operator=(std::initializer_list<T> ilist)
	{
		return *this;
	}

	constexpr void assign(size_type count, const T& value) {}
	template<class InputIt>
	constexpr void assign(InputIt first, InputIt last) {}
	constexpr void assign(std::initializer_list<T> ilist) {}

	template<class R>
	constexpr void assign_range(R&& rg) {}

	constexpr allocator_type get_allocator() const noexcept {}

	constexpr reference at(size_type pos) {}
	constexpr const_reference at(size_type pos) const {}

	constexpr reference operator[](size_type pos) {}
	constexpr const_reference operator[](size_type pos) const {}

	constexpr reference front(size_type pos) {}
	constexpr const_reference front(size_type pos) const {}

	constexpr reference back(size_type pos) {}
	constexpr const_reference back(size_type pos) const {}

	constexpr pointer data() noexcept {}
	constexpr const_pointer data() const {}

	constexpr iterator begin() noexcept {}
	constexpr const_iterator begin() const noexcept {}
	constexpr const_iterator cbegin() const noexcept {}
	constexpr iterator end() noexcept {}
	constexpr const_iterator end() const noexcept {}
	constexpr const_iterator cend() const noexcept {}

	constexpr reverse_iterator rbegin() noexcept {}
	constexpr reverse_const_iterator rbegin() const noexcept {}
	constexpr reverse_const_iterator crbegin() const noexcept {}
	constexpr reverse_iterator rend() noexcept {}
	constexpr reverse_const_iterator rend() const noexcept {}
	constexpr reverse_const_iterator crend() const noexcept {}

	[[nodiscard]] constexpr bool empty() const noexcept { return true; }
	[[nodiscard]] constexpr size_type size() const noexcept { return 0; }
	[[nodiscard]] constexpr size_type max_size() const noexcept { return 0; }

	constexpr void reserve(size_type new_cap) {}
	[[nodiscard]] constexpr size_type capacity() const noexcept { return 0; }
	constexpr void shrink_to_fit() const noexcept {}

	constexpr void clear() noexcept
	{
		this->mResizeLock.lock();
		this->mData.clear();
		this->mTop = 0;
		this->mResizeLock.unlock();
	}

	constexpr iterator insert(const_iterator pos, const T& value) {}
	constexpr iterator insert(const_iterator pos, T&& value) {}
	constexpr iterator insert(const_iterator pos, size_type count, const T& value) {}
	template<class InputIt>
	constexpr iterator insert(const_iterator pos, InputIt first, InputIt last) {}
	constexpr iterator insert(const_iterator pos, std::initializer_list<T> ilist) {}
	template<class R>
	constexpr iterator insert_range(const_iterator pos, R&& rg) {}

	template<class... Args>
	constexpr iterator emplace(const_iterator pos, Args&&... args)
	{
		this->_blockIfNecessary();
		pos->emplace(args...);
	}
	constexpr iterator erase(const_iterator pos)
	{

	}
	constexpr iterator erase(const_iterator first, const_iterator last) {}

	constexpr void push_back(const T& value)
	{
		this->_blockIfNecessary();
		if constexpr (this->mData.size() > this->mTop + 1)
		{
			this->mData[++this->mTop].emplace(value);
		}
	}
	constexpr void push_back(T&& value)
	{
		this->_blockIfNecessary();
		if constexpr (this->mData.size() > this->mTop + 1)
		{
			this->mData[++this->mTop].emplace(std::move(value));
		}
	}
	template<class... Args>
	constexpr reference emplace_back(Args&&... args)
	{
		this->_blockIfNecessary();
		if constexpr (this->mData.size() > this->mTop + 1)
		{
			this->mData[++this->mTop].emplace(args...);
		}
	}
	template<class R>
	constexpr void append_range(R&& rg) {}
	constexpr void pop_back()
	{
		this->mData[this->mTop].reset();
		this->mTop--;
	}
	constexpr void resize(size_type count)
	{
		this->mResizeLock.lock();
		this->mData.resize(count);
		this->mResizeLock.unlock();
	}
	constexpr void resize(size_type count, const value_type& value)
	{
		this->mResizeLock.lock();
		this->mData.resize(count, value);
		this->mResizeLock.unlock();
	}
	constexpr void swap(concurrent_vector& other) noexcept
	{
		std::swap(this->mData, other.mData);
	}

	constexpr bool operator==(const concurrent_vector& rhs)
	{
		return this->mData == rhs.mData;
	}
	constexpr auto operator<=>(const concurrent_vector& rhs)
	{
		return this->mData <=> rhs.mData;
	};

private:
	bool _checkLock()
	{
		if(this->mResizeLock.try_lock())
		{
			this->mResizeLock.unlock();
			return true;
		}
		return false;
	}
	void _blockIfNecessary()
	{
		this->mResizeLock.lock();
		this->mResizeLock.unlock();
	}

	std::vector<std::optional<T>> mData;
	std::mutex mResizeLock;
	std::atomic<size_type> mTop = 0;
};
_END_SBS

#endif